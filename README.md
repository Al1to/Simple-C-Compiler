# Simple C Compiler

### О проекте
Пока что проект недописан. Есть только вроде готовый лексер и минимальный парсер. Позже проект будет дописан.
<br/>
<br/>

## Лексер
Эта штука разбивает текст *(код)* на токены и возвращает вектор со всеми ними. У меня все токены расписаны в `enum Token` в файле `lexer.rs`.
Он умеет обрабатывать все эти символы:
```c
( ) [ ] { } ; , . > < * / % - + & = ! 
```
Также все эти комбинации символов:
```с
>= <= *= /= %= -= -- += ++ && || == != 
```
Еще все эти ключевые слова:
```c
if else for while break continue return int float char void
```
Еще числа, в том числе с точкой.
<br/>Еще умеет обрабатывать char (`'a'`).
<br/>Ну и на конец, все что не стало чем-то из предыдущего и подходит под такие критерии: 
1) начинается с буквы,
2) продолжается буквами, цифрами, или символом `_`,

становится идентификатором - именем переменной, функции, или т.п.
<br/>Ну и в довесок, лексер умеет обрабатывать комментарии, начинающиеся с `//`.
<br/>
<br/>Приведу пример работы лексера. Дан вот такой код на C:
```c
int main() {
    int x = 2;
    x += test(a) + 2;
    return 0;
}
```
Лексер выдаст нам вот такой вектор токенов:
```rust
[IntT, Id { id: "main" }, LP, RP, LC, IntT, Id { id: "x" }, Assignment, Inum { n: 2 }, Semicolon, Id { id: "x" }, AddAssign, Id { id: "test" }, LP, Id { id: "a" }, RP, Plus, Inum { n: 2 }, Semicolon, Return, Inum { n: 0 }, Semicolon, RC]
```
<br/>

## Парсер
// TODO:
